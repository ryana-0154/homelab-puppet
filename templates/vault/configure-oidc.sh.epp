<%- |
  String $vault_addr,
  String $vault_token_file,
  String $oidc_discovery_url,
  String $authentik_client_id,
  String $authentik_client_secret,
  String $default_policy,
  Array[String] $admin_groups,
  String $oidc_config_marker,
| -%>
#!/bin/bash
# Managed by Puppet - Configures Vault OIDC with Authentik
set -e

VAULT_TOKEN=$(cat "<%= $vault_token_file %>")

# Helper function to run vault commands in container
# Use localhost inside container, vault_addr is for external redirect URIs
vault_cmd() {
  docker exec -e VAULT_ADDR="http://127.0.0.1:8200" -e VAULT_TOKEN="${VAULT_TOKEN}" vault vault "$@"
}

# Try to unseal first if unseal script exists
if [ -x /opt/vault/unseal.sh ]; then
  echo "Running unseal script..."
  /opt/vault/unseal.sh || true
fi

# Wait for Vault to be ready and unsealed
for i in {1..30}; do
  if vault_cmd status 2>/dev/null | grep -q "Sealed.*false"; then
    echo "Vault is unsealed and ready"
    break
  fi
  echo "Waiting for Vault to be unsealed... ($i/30)"
  sleep 2
done

# Check if Vault is unsealed
if ! vault_cmd status 2>/dev/null | grep -q "Sealed.*false"; then
  echo "ERROR: Vault is still sealed. Please unseal Vault first."
  exit 1
fi

# Create admin policy if it doesn't exist
if ! vault_cmd policy read admin >/dev/null 2>&1; then
  echo "Creating admin policy..."
  # Write policy to temp file, copy to container, then apply
  cat > /tmp/admin-policy.hcl <<'POLICY'
# Admin policy - full access
path "secret/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}
path "auth/*" {
  capabilities = ["create", "read", "update", "delete", "list", "sudo"]
}
path "sys/policies/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}
path "sys/mounts/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}
path "sys/health" {
  capabilities = ["read"]
}
path "sys/*" {
  capabilities = ["read", "list"]
}
path "identity/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}
POLICY
  docker cp /tmp/admin-policy.hcl vault:/tmp/admin-policy.hcl
  vault_cmd policy write admin /tmp/admin-policy.hcl
  rm -f /tmp/admin-policy.hcl
else
  echo "Admin policy already exists"
fi

# Enable OIDC auth method if not already enabled
if ! vault_cmd auth list 2>/dev/null | grep -q "^oidc/"; then
  echo "Enabling OIDC auth method..."
  vault_cmd auth enable oidc
else
  echo "OIDC auth method already enabled"
fi

# Configure OIDC
echo "Configuring OIDC provider..."
vault_cmd write auth/oidc/config \
  oidc_discovery_url="<%= $oidc_discovery_url %>" \
  oidc_client_id="<%= $authentik_client_id %>" \
  oidc_client_secret="<%= $authentik_client_secret %>" \
  oidc_scopes="openid,profile,email" \
  default_role="default"

# Create default role for all users
echo "Creating default OIDC role..."
vault_cmd write auth/oidc/role/default \
  bound_audiences="<%= $authentik_client_id %>" \
  allowed_redirect_uris="<%= $vault_addr %>/ui/vault/auth/oidc/oidc/callback" \
  allowed_redirect_uris="http://localhost:8250/oidc/callback" \
  user_claim="preferred_username" \
  policies="<%= $default_policy %>"

<% if $admin_groups.length > 0 { -%>
# Create admin role for specified groups
echo "Creating admin OIDC role..."
cat > /tmp/admin-role.json <<'ROLE'
{
  "bound_audiences": "<%= $authentik_client_id %>",
  "allowed_redirect_uris": ["<%= $vault_addr %>/ui/vault/auth/oidc/oidc/callback", "http://localhost:8250/oidc/callback"],
  "user_claim": "preferred_username",
  "groups_claim": "groups",
  "bound_claims": {"groups": [<%= $admin_groups.map |$g| { "\"${g}\"" }.join(', ') %>]},
  "policies": ["admin", "default"]
}
ROLE
docker cp /tmp/admin-role.json vault:/tmp/admin-role.json
vault_cmd write auth/oidc/role/admin @/tmp/admin-role.json
rm -f /tmp/admin-role.json

<% } -%>
# Mark as configured
touch "<%= $oidc_config_marker %>"
echo "OIDC configuration complete!"
